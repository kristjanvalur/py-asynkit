import asyncio
import functools
import types
from .tools import create_task

__all__ = [
    "coro_start",
    "coro_is_blocked",
    "coro_as_future",
    "coro_continue",
    "coro_await",
    "coro_eager",
    "func_eager",
    "eager",
    "coro_get_frame",
    "coro_is_new",
    "coro_is_suspended",
    "coro_is_finished",
]

"""
Tools and utilities for advanced management of coroutines
"""


# Helpers to find if a coroutine (or a generator as created by types.coroutine)
# has started or finished


def _coro_getattr(coro, suffix):
    """
    Get an attribute of a coroutine or coroutine like object
    """
    # look for
    # 1. coroutine
    # 2. legacy coroutine (even wrapped with types.coroutine())
    # 3. async generator
    for prefix in ("cr_", "gi_", "ag_"):
        if hasattr(coro, prefix + suffix):
            if prefix == "ag_" and suffix == "running":
                return False  # async generators are shown as ag_running=True, even when the code is not executiong.  Override that.
            # coroutine (async function)
            return getattr(coro, prefix + suffix)
    raise TypeError("a coroutine or coroutine like object is required")


def coro_get_frame(coro):
    """
    Get the current frame of a coroutine or coroutine like object (generator, legacy coroutines)
    """
    return _coro_getattr(coro, "frame")


def coro_is_new(coro):
    """
    Returns True if the coroutine has just been created and
    never not yet started
    """
    frame = coro_get_frame(coro)
    return frame is not None and frame.f_lasti < 0


def coro_is_suspended(coro):
    """
    Returns True if the coroutine has started but not exited
    """
    frame = coro_get_frame(coro)
    # frame is None if it has already exited
    # the currently running coroutine is also not suspended by definition.
    return (
        frame is not None and frame.f_lasti >= 0 and not _coro_getattr(coro, "running")
    )


def coro_is_finished(coro):
    """
    Returns True if the coroutine has finished execution, either by
    returning or throwing an exception
    """
    return coro_get_frame(coro) is None


def coro_start(coro):
    """
    Start the coroutine execution.  It runs te coroutine to its first blocking point
    or until it raises an exception or returns a value, whichever comes first.
    returns a tuple, (coro, future, exception), where one of future/exception is always `None`.
    The tuple can be passed to `coro_continue` to continue execution, or if
    `exception is not none` it can be processed right away.
    If the exception is a `StopIteration` the `exception.value` can be returned,
    otherwise the exception can be raised directly.
    """
    try:
        future = coro.send(None)
    except BaseException as exception:
        # Coroutine returned without blocking
        return coro, None, exception
    else:
        return coro, future, None


def coro_is_blocked(coro_state):
    """
    Return True if coroutine started by coro_start() is in a blocked state,
    False, if it returned a value or raised an exception
    """
    return coro_state[2] is None


def coro_as_future(coro_state):
    """
    Convert a non-blocked (i.e. finished) coroutine_state into a future.
    """
    future = asyncio.Future()
    exception = coro_state[2]
    if isinstance(exception, StopIteration):
        future.set_result(exception.value)
    else:
        future.set_exception(exception)
    return future


@types.coroutine
def coro_continue(coro_state):
    """
    Continue execution of the coroutine that was started by coro_start()
    """
    coro, out_value, out_exception = coro_state
    # process any exception generated by the initial start
    if out_exception:
        if isinstance(out_exception, StopIteration):
            return out_exception.value
        raise out_exception

    # yield up the initial future from `coro_start`.
    # This is similar to how `yield from` is defined (see pep-380)
    # except that it uses a coroutines's send() and throw() methods.
    while True:
        try:
            in_value = yield out_value
        except GeneratorExit:  # pragma: no coverage
            # asyncio lib does not appear to ever close coroutines.
            coro.close()
            raise
        except BaseException as e:
            try:
                out_value = coro.throw(e)
            except StopIteration as e:
                return e.value
        else:
            try:
                out_value = coro.send(in_value)
            except StopIteration as e:
                return e.value


async def coro_await(coro):
    """
    A simple await, using the partial run primitives, equivalent to
    `async def coro_await(coro): return await coro`
    """
    return await coro_continue(coro_start(coro))


def coro_eager(coro):
    """
    Make the coroutine "eager":
    Start the coroutine.  If it blocks, create a task to continue
    execution and return immediately to the caller.
    The return value is either a non-blocking awaitable returning any
    result or exception, or a Task object.
    This implements a depth-first kind of Task execution.
    """

    # start the coroutine.  Run it to the first block, exception or return value.
    coro_state = coro_start(coro)
    if not coro_is_blocked(coro_state):
        # The coroutine didn't block, a result or exception is ready.
        # We could simply `return coro_continue(coro_state)` but we
        # reate a future, so that methods like `asyncio.gather`
        # don't unnecessarily wrap it into a task.
        return coro_as_future(coro_state)
    else:
        # otherwise, return a Task that runs the coroutine to completion
        return create_task(coro_continue(coro_state))


def func_eager(func):
    """
    Decorator to automatically apply the `coro_eager` to the
    coroutine generated by invoking the given async function
    """

    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        return coro_eager(func(*args, **kwargs))

    return wrapper


def eager(arg):
    """
    Convenience function invoking either `coro_eager` or `func_eager`
    to either decorate an async function or convert a coroutine returned by
    invoking an async function.
    """
    if isinstance(arg, types.CoroutineType):
        # A coroutine
        return coro_eager(arg)
    if isinstance(arg, types.FunctionType):
        return func_eager(arg)
    raise TypeError("need coroutine or function")
